Here's a breakdown of all major **DSA problem patterns** along with their **varieties** to help you systematically master problem-solving.

---

## **1. Sliding Window**

- **Fixed-size window** (e.g., Maximum sum of subarray of size k)
- **Variable-size window** (e.g., Longest substring with at most k distinct characters)
- **Two-pointer based sliding window** (e.g., Minimum window substring)
- **Cyclic sliding window** (e.g., Circular array problems)

---

## **2. Two Pointers**

- **Opposite end pointers** (e.g., Two sum in sorted array)
- **Same-direction pointers** (e.g., Removing duplicates from sorted array)
- **Merging pointers** (e.g., Merge sorted arrays)
- **Partitioning problems** (e.g., Dutch National Flag problem)

---

## **3. Slow and Fast Pointers (Tortoise-Hare)**

- **Cycle detection** (e.g., Detect cycle in linked list)
- **Finding the cycle start** (e.g., Find cycle's starting node)
- **Finding the middle of a list** (e.g., Find middle element of linked list)
- **Finding intersection point in lists** (e.g., Intersection of two linked lists)

---

## **4. Merge Intervals**

- **Overlapping intervals** (e.g., Merge intervals)
- **Non-overlapping intervals** (e.g., Insert interval)
- **Minimum rooms required (sweep line technique)** (e.g., Meeting rooms)
- **Finding gaps between intervals** (e.g., Employee free time)

---

## **5. Cyclic Sort**

- **Find missing numbers** (e.g., Find missing positive integer)
- **Find duplicate numbers** (e.g., Find duplicate number)
- **Find all missing numbers** (e.g., Find all missing numbers in an array)
- **Sort a range of numbers** (e.g., Sort numbers in range 1 to N)

---

## **6. Subsets (Power Set)**

- **All subsets of an array** (e.g., Power set)
- **Subset sum problems** (e.g., Partition equal subset sum)
- **Permutations of elements** (e.g., Permutations of string)
- **Combinations of elements** (e.g., Letter case permutation)

---

## **7. Modified Binary Search**

- **Basic search** (e.g., Binary search on sorted array)
- **Search in rotated sorted array** (e.g., Find min in rotated array)
- **Search in nearly sorted array** (e.g., Binary search with misplaced elements)
- **Find peak element** (e.g., Local maximum in an array)

---

## **8. Bit Manipulation**

- **Finding unique element** (e.g., Single number)
- **Checking power of two** (e.g., Power of two check)
- **Counting set bits** (e.g., Number of 1s in binary)
- **XOR-based tricks** (e.g., Missing number using XOR)

---

## **9. Top K Elements (Heap/Priority Queue)**

- **Find Kth largest/smallest** (e.g., Kth largest element)
- **Sort an array based on frequency** (e.g., Top K frequent elements)
- **K closest elements** (e.g., K closest points to origin)
- **Rearrange elements** (e.g., Reorganize string with adjacent characters different)

---

## **10. K-Way Merge (Heap)**

- **Merge sorted lists** (e.g., Merge k sorted lists)
- **Find smallest range covering elements from k lists** (e.g., Smallest range covering elements from k lists)
- **Find Kth smallest number in a sorted matrix** (e.g., Kth smallest element in a sorted matrix)

---

## **11. Backtracking**

- **Combinations** (e.g., Combination sum)
- **Permutations** (e.g., String permutations)
- **Sudoku solver** (e.g., Solving Sudoku)
- **N-Queens problem** (e.g., Place N queens on an NxN chessboard)

---

## **12. Dynamic Programming (DP)**

- **0/1 Knapsack variations** (e.g., Subset sum, Partition equal subset sum)
- **Unbounded Knapsack variations** (e.g., Coin change, Rod cutting)
- **Fibonacci-style DP** (e.g., Climbing stairs, House robber)
- **Longest subsequence problems** (e.g., LIS, LCS, Edit Distance)
- **Matrix-based DP** (e.g., Unique paths, Min path sum)
- **Palindrome-based DP** (e.g., Longest palindromic subsequence)
- **Interval DP** (e.g., Burst balloons, MCM)

---

## **13. Graph Traversal (BFS/DFS)**

- **Graph traversal** (e.g., BFS, DFS)
- **Shortest path (Dijkstra, Bellman-Ford, Floyd-Warshall)** (e.g., Network delay time)
- **Cycle detection** (e.g., Detect cycle in directed/undirected graph)
- **Topological sorting** (e.g., Course schedule)
- **Connected components (Union-Find/DFS)** (e.g., Number of islands)

---

## **14. Trie (Prefix Tree)**

- **Insert and search words** (e.g., Implement Trie)
- **Autocomplete system** (e.g., Search suggestions system)
- **Word break problem** (e.g., Word break using Trie)
- **Longest common prefix** (e.g., Find longest common prefix in words)

---

## **15. Greedy Algorithms**

- **Activity selection** (e.g., Maximum non-overlapping activities)
- **Huffman coding** (e.g., Huffman encoding for compression)
- **Interval scheduling** (e.g., Meeting rooms problem)
- **Job sequencing** (e.g., Maximize job scheduling profit)

---

## **16. Matrix Problems**

- **Matrix traversal** (e.g., Spiral matrix)
- **Search in sorted matrix** (e.g., Search a 2D matrix)
- **Connected components (Flood Fill)** (e.g., Number of islands)
- **Rotate and transpose** (e.g., Rotate image)

---

## **17. Monotonic Stack / Queue**

- **Next greater element** (e.g., Next greater element in an array)
- **Largest rectangle in histogram** (e.g., Maximal rectangle)
- **Sliding window maximum** (e.g., Max in each window of size k)

---

## **18. Prefix Sum & Difference Array**

- **Range sum queries** (e.g., Range sum query using prefix sum)
- **Difference array** (e.g., Applying multiple range updates efficiently)
- **Subarray sum problems** (e.g., Find subarray with given sum)

---

## **19. Disjoint Set (Union-Find)**

- **Connected components** (e.g., Friend circles problem)
- **Cycle detection** (e.g., Detect cycle using union-find)
- **Kruskalâ€™s Algorithm** (e.g., Minimum spanning tree)

---

## **20. String Processing**

- **KMP / Rabin-Karp** (e.g., String pattern matching)
- **Z-function & LPS array** (e.g., Finding shortest palindrome)
- **Anagram problems** (e.g., Group anagrams)
- **Palindrome problems** (e.g., Longest palindromic substring)

---

### **Final Thoughts**

This list covers **all essential DSA patterns and their variations**. To master them:

- Solve **at least 3-5 problems** in each category.
- Recognize patterns and **map new problems** to known templates.
- Focus on **time-space trade-offs** in different approaches.

Would you like a structured **study roadmap** to go through these efficiently?